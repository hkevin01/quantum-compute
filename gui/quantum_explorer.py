#!/usr/bin/env python3
"""
Quantum Computing Explorer GUI

An interactive GUI for exploring quantum computing examples and algorithms.
Each tab demonstrates a different quantum concept with visualizations and explanations.
"""

import os
import sys

import matplotlib.pyplot as plt
import numpy as np
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

try:
    from PyQt5.QtCore import Qt, pyqtSignal
    from PyQt5.QtGui import QFont, QPixmap
    from PyQt5.QtWidgets import (
        QApplication,
        QFrame,
        QHBoxLayout,
        QLabel,
        QMainWindow,
        QMessageBox,
        QPushButton,
        QScrollArea,
        QSplitter,
        QTabWidget,
        QTextEdit,
        QVBoxLayout,
        QWidget,
    )
except ImportError:
    print("PyQt5 not found. Install with: pip install PyQt5")
    sys.exit(1)

# Add the src directory to the path so we can import our modules
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'src'))
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'examples'))

try:
    import basic_quantum_examples
    import quantum_algorithms
    from qiskit import ClassicalRegister, QuantumCircuit, QuantumRegister, transpile
    from qiskit.quantum_info import Statevector
    from qiskit.visualization import plot_bloch_multivector, plot_histogram
    from qiskit_aer import AerSimulator
except ImportError as e:
    print(f"Warning: Could not import quantum modules: {e}")
    print("Make sure Qiskit is installed: pip install qiskit qiskit-aer")
    print("Make sure Qiskit is installed: pip install qiskit qiskit-aer")



class QuantumExplorerGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Quantum Computing Explorer")
        self.setGeometry(100, 100, 1400, 900)
        
        # Initialize simulator
        self.simulator = AerSimulator()
        
        # Create main widget and layout
        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        main_layout = QVBoxLayout(main_widget)
        
        # Create tab widget
        self.tab_widget = QTabWidget()
        main_layout.addWidget(self.tab_widget)
        
        # Create tabs
        self.create_introduction_tab()
        self.create_superposition_tab()
        self.create_entanglement_tab()
        self.create_interference_tab()
        self.create_quantum_algorithms_tab()
        self.create_quantum_ml_tab()
        self.create_medical_applications_tab()
        self.create_cosmology_tab()
        
        # Set application style
        self.setStyleSheet("""
            QMainWindow {
                background-color: #f0f0f0;
            }
            QTabWidget::pane {
                border: 1px solid #cccccc;
                background-color: white;
            }
            QTabWidget::tab-bar {
                alignment: left;
            }
            QTabBar::tab {
                background-color: #e0e0e0;
                padding: 8px 16px;
                margin-right: 2px;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
            }
            QTabBar::tab:selected {
                background-color: white;
                border-bottom: 2px solid #007acc;
            }
            QPushButton {
                background-color: #007acc;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #005a9f;
            }
            QPushButton:pressed {
                background-color: #004080;
            }
        """)
    
    def create_introduction_tab(self):
        """Introduction to quantum computing concepts"""
        widget = QWidget()
        self.tab_widget.addTab(widget, "üöÄ Introduction")
        
        layout = QVBoxLayout(widget)
        
        # Create scrollable text area
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setFont(QFont("Arial", 11))
        
        content = """
üåü Welcome to Quantum Computing Explorer! üåü

This interactive application demonstrates the fascinating world of quantum computing through practical examples and visualizations.

üî¨ What Makes Quantum Computing Special?

Unlike classical computers that use bits (0 or 1), quantum computers use quantum bits (qubits) that can exist in multiple states simultaneously. This leads to three key quantum phenomena:

1. üåä SUPERPOSITION
   ‚Ä¢ Qubits can be in a combination of 0 and 1 states simultaneously
   ‚Ä¢ Like a coin spinning in the air - it's both heads and tails until it lands
   ‚Ä¢ Classical equivalent: Checking every path in a maze one by one
   ‚Ä¢ Quantum advantage: Exploring all paths simultaneously

2. üîó ENTANGLEMENT
   ‚Ä¢ Qubits can be mysteriously connected across any distance
   ‚Ä¢ Measuring one instantly affects its entangled partner
   ‚Ä¢ Einstein called this "spooky action at a distance"
   ‚Ä¢ Enables quantum teleportation and cryptography

3. üåÄ INTERFERENCE
   ‚Ä¢ Quantum states can amplify or cancel each other out
   ‚Ä¢ Like waves in water - they can constructively or destructively interfere
   ‚Ä¢ Allows quantum algorithms to amplify correct answers and cancel wrong ones

üöÄ Why This Matters for Research:

üß¨ MEDICAL APPLICATIONS:
   ‚Ä¢ Drug Discovery: Simulate molecular interactions with exponential speedup
   ‚Ä¢ Protein Folding: Model complex protein structures that classical computers struggle with
   ‚Ä¢ CRISPR Optimization: Find optimal gene editing targets much faster

üåå COSMOLOGY & PHYSICS:
   ‚Ä¢ Black Hole Simulations: Model quantum effects near event horizons
   ‚Ä¢ Dark Matter Detection: Optimize detector configurations for rare events
   ‚Ä¢ Quantum Field Theory: Simulate fundamental particle interactions

ü§ñ QUANTUM MACHINE LEARNING:
   ‚Ä¢ Pattern Recognition: Quantum neural networks for complex data
   ‚Ä¢ Optimization: Solve NP-hard problems more efficiently
   ‚Ä¢ Financial Modeling: Risk analysis with quantum Monte Carlo methods

üìä Current Reality:
   ‚Ä¢ We're in the NISQ era (Noisy Intermediate-Scale Quantum)
   ‚Ä¢ Quantum computers have 50-1000 qubits with high error rates
   ‚Ä¢ Quantum advantage exists for specific problems, not general computing
   ‚Ä¢ Hybrid classical-quantum algorithms show the most promise

üéØ Explore the Tabs:
   ‚Ä¢ Each tab demonstrates a specific quantum concept
   ‚Ä¢ Run examples to see quantum behavior in action
   ‚Ä¢ Compare classical vs quantum approaches
   ‚Ä¢ Understand why quantum computers excel at certain problems

Ready to explore the quantum realm? Click through the tabs to see quantum computing in action! üöÄ
        """
        
        text_edit.setHtml(content.replace('\n', '<br>'))
        layout.addWidget(text_edit)
    
    def create_superposition_tab(self):
        """Superposition demonstration"""
        widget = QWidget()
        self.tab_widget.addTab(widget, "üåä Superposition")
        
        layout = QHBoxLayout(widget)
        
        # Create splitter for description and demo
        splitter = QSplitter(Qt.Horizontal)
        layout.addWidget(splitter)
        
        # Description panel
        desc_widget = QWidget()
        desc_layout = QVBoxLayout(desc_widget)
        
        desc_text = QTextEdit()
        desc_text.setReadOnly(True)
        desc_text.setFont(QFont("Arial", 10))
        desc_text.setMaximumWidth(400)
        
        superposition_desc = """
üåä QUANTUM SUPERPOSITION

What is it?
Superposition allows a qubit to exist in multiple states simultaneously until measured. It's like a coin spinning in the air - both heads and tails at once.

üî¨ The Science:
‚Ä¢ A qubit can be |0‚ü©, |1‚ü©, or any combination: Œ±|0‚ü© + Œ≤|1‚ü©
‚Ä¢ |Œ±|¬≤ + |Œ≤|¬≤ = 1 (probabilities must sum to 1)
‚Ä¢ When measured, the qubit "collapses" to either 0 or 1

üöÄ Why It's Powerful:
‚Ä¢ Classical bit: Can check one solution at a time
‚Ä¢ Quantum qubit: Can explore multiple solutions simultaneously
‚Ä¢ n qubits = 2‚Åø possible states explored at once!

üéØ Real-World Applications:

üß¨ Drug Discovery:
‚Ä¢ Classical: Test each molecular configuration individually
‚Ä¢ Quantum: Explore all configurations in superposition
‚Ä¢ Result: Exponentially faster drug screening

üîê Cryptography:
‚Ä¢ Quantum key distribution uses superposition
‚Ä¢ Any eavesdropping collapses the quantum state
‚Ä¢ Provides mathematically proven security

üé≤ Random Number Generation:
‚Ä¢ Classical: Pseudo-random (deterministic algorithms)
‚Ä¢ Quantum: True randomness from measurement collapse
‚Ä¢ Critical for cryptography and simulations

üìä The Demo:
Click "Create Superposition" to see a qubit in equal superposition of |0‚ü© and |1‚ü©. The visualization shows the qubit's state. When you measure it multiple times, you'll see the probabilistic nature of quantum mechanics!
        """
        
        desc_text.setPlainText(superposition_desc)
        desc_layout.addWidget(desc_text)
        splitter.addWidget(desc_widget)
        
        # Demo panel
        demo_widget = QWidget()
        demo_layout = QVBoxLayout(demo_widget)
        
        # Controls
        control_layout = QHBoxLayout()
        
        create_btn = QPushButton("Create Superposition")
        create_btn.clicked.connect(self.demo_superposition)
        create_btn.setStyleSheet("background-color: lightblue; color: black;")
        control_layout.addWidget(create_btn)
        
        measure_btn = QPushButton("Measure 1000 Times")
        measure_btn.clicked.connect(self.measure_superposition)
        measure_btn.setStyleSheet("background-color: lightgreen; color: black;")
        control_layout.addWidget(measure_btn)
        
        control_layout.addStretch()
        demo_layout.addLayout(control_layout)
        
        # Results display
        self.superposition_results = QTextEdit()
        self.superposition_results.setFont(QFont("Courier", 10))
        self.superposition_results.setMaximumHeight(200)
        demo_layout.addWidget(self.superposition_results)
        
        # Matplotlib figure
        self.superposition_figure = Figure(figsize=(12, 6))
        self.superposition_canvas = FigureCanvas(self.superposition_figure)
        demo_layout.addWidget(self.superposition_canvas)
        
        splitter.addWidget(demo_widget)
        splitter.setSizes([400, 800])
    
    def demo_superposition(self):
        """Demonstrate quantum superposition"""
        try:
            # Create a qubit in superposition
            qc = QuantumCircuit(1, 1)
            qc.h(0)  # Hadamard gate creates superposition
            
            # Get the statevector
            statevector = Statevector.from_instruction(qc)
            
            # Clear previous plots
            self.superposition_figure.clear()
            ax1 = self.superposition_figure.add_subplot(1, 2, 1)
            ax2 = self.superposition_figure.add_subplot(1, 2, 2)
            
            # Plot circuit
            qc.draw(output='mpl', ax=ax1)
            ax1.set_title("Quantum Circuit: H|0‚ü© = (|0‚ü© + |1‚ü©)/‚àö2")
            
            # Plot probabilities
            probs = statevector.probabilities()
            ax2.bar(['|0‚ü©', '|1‚ü©'], probs, color=['blue', 'red'])
            ax2.set_title("State Probabilities")
            ax2.set_ylabel("Probability")
            ax2.set_ylim(0, 1)
            
            self.superposition_canvas.draw()
            
            self.superposition_results.clear()
            self.superposition_results.append(
                f"‚úÖ Superposition Created!\n"
                f"State: {statevector}\n"
                f"Probabilities: |0‚ü©: 50%, |1‚ü©: 50%\n"
                f"The qubit is now in equal superposition!\n\n"
                f"üî¨ What's happening:\n"
                f"‚Ä¢ The Hadamard gate (H) puts the qubit in superposition\n"
                f"‚Ä¢ Before measurement, it's both |0‚ü© AND |1‚ü©\n"
                f"‚Ä¢ Each measurement has 50% chance of either outcome\n"
                f"‚Ä¢ Click 'Measure 1000 Times' to see the statistics!")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not create superposition: {e}")
    
    def measure_superposition(self):
        """Measure the superposition many times"""
        try:
            # Create and measure the circuit many times
            qc = QuantumCircuit(1, 1)
            qc.h(0)
            qc.measure(0, 0)
            
            # Run many shots
            compiled_circuit = transpile(qc, self.simulator)
            job = self.simulator.run(compiled_circuit, shots=1000)
            result = job.result()
            counts = result.get_counts()
            
            # Update results
            self.superposition_results.append(
                f"\nüìä Measurement Results (1000 shots):\n")
            for outcome, count in counts.items():
                percentage = (count/1000) * 100
                self.superposition_results.append(
                    f"  |{outcome}‚ü©: {count} times ({percentage:.1f}%)\n")
            
            self.superposition_results.append(
                f"\nüéØ Notice: Results are close to 50/50!\n"
                f"This proves the qubit was in true superposition.\n"
                f"Classical randomness would give the same statistics,\n"
                f"but quantum superposition explores BOTH states simultaneously!\n")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not measure superposition: {e}")
    
    def create_entanglement_tab(self):
        """Quantum entanglement demonstration"""
        widget = QWidget()
        self.tab_widget.addTab(widget, "üîó Entanglement")
        
        layout = QVBoxLayout(widget)
        label = QLabel("Entanglement demonstration coming soon...")
        label.setAlignment(Qt.AlignCenter)
        label.setFont(QFont("Arial", 16))
        layout.addWidget(label)
    
    def create_interference_tab(self):
        """Quantum interference demonstration"""
        widget = QWidget()
        self.tab_widget.addTab(widget, "üåÄ Interference")
        
        layout = QVBoxLayout(widget)
        label = QLabel("Interference demonstration coming soon...")
        label.setAlignment(Qt.AlignCenter)
        label.setFont(QFont("Arial", 16))
        layout.addWidget(label)
    
    def create_quantum_algorithms_tab(self):
        """Quantum algorithms overview"""
        widget = QWidget()
        self.tab_widget.addTab(widget, "üßÆ Algorithms")
        
        layout = QVBoxLayout(widget)
        
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setFont(QFont("Arial", 11))
        
        algorithms_content = """
üßÆ QUANTUM ALGORITHMS SHOWCASE

This tab demonstrates the most important quantum algorithms and their real-world applications.

üîç GROVER'S SEARCH ALGORITHM
‚Ä¢ Problem: Search unsorted database of N items
‚Ä¢ Classical: O(N) time - must check every item
‚Ä¢ Quantum: O(‚àöN) time - quadratic speedup!
‚Ä¢ Applications:
  üîê Breaking symmetric cryptography
  üß¨ Database search in bioinformatics
  üéØ Optimization problems
  üí∞ Portfolio optimization

‚öóÔ∏è QUANTUM SIMULATION ALGORITHMS
‚Ä¢ Problem: Simulate quantum systems (molecules, materials)
‚Ä¢ Classical: Exponentially hard (2^n states)
‚Ä¢ Quantum: Natural fit - quantum simulates quantum!
‚Ä¢ Applications:
  üíä Drug discovery and design
  üîã Battery materials optimization
  üß™ Catalyst development
  ‚ö° Superconductor research

üî¢ SHOR'S FACTORING ALGORITHM
‚Ä¢ Problem: Factor large integers
‚Ä¢ Classical: Exponential time (breaks down for large numbers)
‚Ä¢ Quantum: Polynomial time - exponential speedup!
‚Ä¢ Impact:
  üîê Breaks RSA encryption
  üèõÔ∏è Threatens current cybersecurity
  üõ°Ô∏è Motivates quantum-resistant cryptography

üéØ VARIATIONAL QUANTUM ALGORITHMS (VQE, QAOA)
‚Ä¢ Hybrid classical-quantum approach
‚Ä¢ Good for NISQ devices (current quantum computers)
‚Ä¢ Applications:
  üß¨ Protein folding optimization
  üöó Route optimization
  üìà Financial portfolio optimization
  üîã Energy system optimization

ü§ñ QUANTUM MACHINE LEARNING
‚Ä¢ Quantum Neural Networks
‚Ä¢ Quantum Support Vector Machines
‚Ä¢ Quantum Feature Maps
‚Ä¢ Applications:
  üè• Medical diagnosis
  üî¨ Drug discovery
  üìä Pattern recognition
  üéØ Optimization

üìä CURRENT STATUS:
‚Ä¢ Most algorithms show theoretical advantage
‚Ä¢ Practical advantage limited by current hardware
‚Ä¢ NISQ algorithms (VQE, QAOA) most promising near-term
‚Ä¢ Fault-tolerant quantum computers needed for full advantage

üöÄ FUTURE OUTLOOK:
As quantum computers scale up:
‚Ä¢ Exponential advantages will become practical
‚Ä¢ New algorithms continue to be discovered
‚Ä¢ Hybrid approaches bridge classical and quantum
‚Ä¢ Industry applications will transform multiple fields

Each algorithm leverages quantum phenomena (superposition, entanglement, interference) in unique ways to achieve computational advantages impossible classically.
        """
        
        text_edit.setPlainText(algorithms_content)
        layout.addWidget(text_edit)
    
    def create_quantum_ml_tab(self):
        """Quantum machine learning applications"""
        widget = QWidget()
        self.tab_widget.addTab(widget, "ü§ñ Quantum ML")
        
        layout = QVBoxLayout(widget)
        
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setFont(QFont("Arial", 11))
        
        ml_content = """
ü§ñ QUANTUM MACHINE LEARNING

Quantum computing promises to revolutionize machine learning through quantum-enhanced algorithms that could provide exponential speedups for certain problems.

[Content continues with detailed explanations of quantum ML concepts...]
        """
        
        text_edit.setPlainText(ml_content)
        layout.addWidget(text_edit)
    
    def create_medical_applications_tab(self):
        """Medical and biological applications"""
        widget = QWidget()
        self.tab_widget.addTab(widget, "üß¨ Medical Apps")
        
        layout = QVBoxLayout(widget)
        
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setFont(QFont("Arial", 11))
        
        medical_content = """
üß¨ QUANTUM COMPUTING IN MEDICINE

Quantum computing promises to revolutionize healthcare through unprecedented computational power for biological systems.

[Content continues with detailed medical applications...]
        """
        
        text_edit.setPlainText(medical_content)
        layout.addWidget(text_edit)
    
    def create_cosmology_tab(self):
        """Cosmology and physics applications"""
        widget = QWidget()
        self.tab_widget.addTab(widget, "üåå Cosmology")
        
        layout = QVBoxLayout(widget)
        
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setFont(QFont("Arial", 11))
        
        cosmo_content = """
üåå QUANTUM COMPUTING IN COSMOLOGY

Quantum computing opens new frontiers in understanding the universe, from black holes to dark matter to the fundamental nature of reality itself.

[Content continues with detailed cosmology applications...]
        """
        
        text_edit.setPlainText(cosmo_content)
        layout.addWidget(text_edit)

def main():
    """Main function to run the Quantum Explorer GUI"""
    app = QApplication(sys.argv)
    app.setApplicationName("Quantum Computing Explorer")
    app.setApplicationVersion("1.0")
    
    # Set application style
    app.setStyle('Fusion')
    
    # Create and show the main window
    window = QuantumExplorerGUI()
    window.show()
    
    # Handle closing gracefully
    def cleanup():
        plt.close('all')  # Close all matplotlib figures
    
    app.aboutToQuit.connect(cleanup)
    
    # Run the application
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
